var documenterSearchIndex = {"docs":
[{"location":"#Recyclers.jl","page":"Recyclers.jl","title":"Recyclers.jl","text":"","category":"section"},{"location":"","page":"Recyclers.jl","title":"Recyclers.jl","text":"Recyclers","category":"page"},{"location":"#Recyclers","page":"Recyclers.jl","title":"Recyclers","text":"Recyclers\n\nRecyclers.jl is a set of tools for implementing memory reuse patterns in multi-tasking Julia programs.\n\njulia> using Recyclers\n\njulia> recycler = Recyclers.CentralizedRecycler(() -> zeros(3));\n\njulia> xs = Recyclers.get!(recycler)  # get a cached object or create a new one\n3-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n\njulia> Recyclers.recycle!(recycler, xs)  # returns `true` if recycled\ntrue\n\n\n\n\n\n","category":"module"},{"location":"#Constructors","page":"Recyclers.jl","title":"Constructors","text":"","category":"section"},{"location":"","page":"Recyclers.jl","title":"Recyclers.jl","text":"Recyclers.AbstractRecycler\nRecyclers.ShardedRecycler\nRecyclers.CentralizedRecycler\nRecyclers.@global\nRecyclers.AbstractCache","category":"page"},{"location":"#Recyclers.AbstractRecycler","page":"Recyclers.jl","title":"Recyclers.AbstractRecycler","text":"AbstractRecycler{T}\n\nA high-level object recycling interface.  It pairs an AbstractCache{T} with an object factory function.\n\nA concrete subtype Recycler{T} of AbstractRecycler{T} (e.g., ShardedRecycler) have the following constructor methods:\n\nRecycler{T}(factory)\nRecycler(factory)\n\nwhere factory is a zero-argument function that returns an object of type T and objects is an iterable with elements of type T.  The constructor of each Recycler subtype may accept additional keyword arguments.\n\nfactory function contracts.  The program author calling Recycler constructor must verify that invocation of factory function on arbitrary worker thread does not introduce any concurrency problems including data races.  When used with the method Recycler{T}(factory), the factory function must return an object of type T (where T does not have to be concrete; i.e., T = Any always works).  A run-time error is thrown if factory is called and return an object that is not of type T.  When used with the method Recycler(factory), the factory function must be type-stable in the sense that objects o1 = factory() and o2 = factory() obtained in arbitrary calling contexts must satisfy typeof(o1) === typeof(o2).  With any constructor methods, changes in the return type of factory function after construction of the recycler may result in run-time error.\n\nSupported methods:\n\nRecyclers.get!(recycler)\nRecyclers.maybeget!(recycler)\nRecyclers.recycle!(recycler, object)\nRecyclers.recycling!(body, recycler)\nRecyclers.unsafe_empty!(recycler)\n\n\n\n\n\n","category":"type"},{"location":"#Recyclers.ShardedRecycler","page":"Recyclers.jl","title":"Recyclers.ShardedRecycler","text":"Recyclers.ShardedRecycler{T}(factory; [limit])\nRecyclers.ShardedRecycler(factory; [limit])\n\nCreate a sharded object recycler.  See AbstractRecycler for more information on the constructor and supported methods.\n\nwarning: Warning\nThe factory function must not introduce any concurrency problems. See see AbstractRecycler for more information.\n\nShardedRecycler uses a stack of size bounded by limit for each worker thread.  The keyword argument limit must be a positive integer less than typemax(UInt) or Inf.\n\n\n\n\n\n","category":"type"},{"location":"#Recyclers.CentralizedRecycler","page":"Recyclers.jl","title":"Recyclers.CentralizedRecycler","text":"Recyclers.CentralizedRecycler{T}(factory)\nRecyclers.CentralizedRecycler(factory)\n\nCreate a centralized object recycler.  See AbstractRecycler for more information on the constructor and supported methods.\n\nwarning: Warning\nThe factory function must not introduce any concurrency problems. See see AbstractRecycler for more information.\n\nCentralizedRecycler uses a lock-free unbounded stack.  It supports thread-safe empty!(recycler) method.\n\n\n\n\n\n","category":"type"},{"location":"#Recyclers.@global","page":"Recyclers.jl","title":"Recyclers.@global","text":"Recyclers.@global recycler_name = make_recycler\n\nDeclare a global constant named recycler_name (a symbol) which holds a recycler created by make_recycler (an expression).\n\nThe recycler is re-initialized (using Recyclers.unsafe_init!) while importing the package in which recycler_name is defined.\n\nIf it can be ensured that no tasks are requiring to access recycler_name during exit, it may be a good idea to call Recyclers.unsafe_destroy! or Recyclers.unsafe_empty!  via atexit.\n\nExample:\n\nRecyclers.@global INTS_RECYCLER = Recyclers.ShardedRecycler(() -> Vector{Int}(undef, 100))\natexit() do\n    Recyclers.unsafe_destroy!(INTS_RECYCLER)\nend\n\n\n\n\n\n","category":"macro"},{"location":"#Recyclers.AbstractCache","page":"Recyclers.jl","title":"Recyclers.AbstractCache","text":"AbstractCache{T}\n\nA low-level object recycling interface.\n\nSupported methods:\n\nRecyclers.get!(factory, cache)\nRecyclers.maybeget!(cache)\nRecyclers.recycle!(cache, object)\nRecyclers.recycling!(body, factory, cache)\nRecyclers.unsafe_empty!(cache)\n\nSee also: AbstractRecycler\n\n\n\n\n\n","category":"type"},{"location":"#Recycling-objects","page":"Recyclers.jl","title":"Recycling objects","text":"","category":"section"},{"location":"","page":"Recyclers.jl","title":"Recyclers.jl","text":"Recyclers.get!\nRecyclers.maybeget!\nRecyclers.recycle!\nRecyclers.recycling!","category":"page"},{"location":"#Recyclers.get!","page":"Recyclers.jl","title":"Recyclers.get!","text":"Recyclers.get!(recycler::AbstractRecycler{T}) -> object::T\nRecyclers.get!(factory, cache::AbstractCache{T}) -> object::T\n\nObtain cached object of type T or create a new one using factory().\n\nwarning: Warning\nThe factory function must not introduce any concurrency problems. See see AbstractRecycler for more information.\n\n\n\n\n\n","category":"function"},{"location":"#Recyclers.maybeget!","page":"Recyclers.jl","title":"Recyclers.maybeget!","text":"Recyclers.maybeget!(recycler::AbstractRecycler{T}) -> Some{T}(object) or nothing\nRecyclers.maybeget!(cache::AbstractCache{T}) -> Some{T}(object) or nothing\n\nObtain cached object wrapped in a Some{T} or nothing.\n\n\n\n\n\n","category":"function"},{"location":"#Recyclers.recycle!","page":"Recyclers.jl","title":"Recyclers.recycle!","text":"Recyclers.recycle!(recycler::AbstractRecycler{T}), object::T) -> isrecycled::Bool\nRecyclers.recycle!(cache::AbstractCache{T}), object::T) -> isrecycled::Bool\n\nTry to recycle a object and return true if and only if the object is recycled.\n\n\n\n\n\n","category":"function"},{"location":"#Recyclers.recycling!","page":"Recyclers.jl","title":"Recyclers.recycling!","text":"Recyclers.recycle!(body, recycler::AbstractRecycler{T})) -> result\nRecyclers.recycle!(body, factory, cache::AbstractCache{T})) -> result\n\nCall a single-argument function body with a object, try to recycle the object, and then return the result returned from body.\n\nThe object is not recycled if body throws since the invariance of object may not hold any more.\n\n\n\n\n\n","category":"function"},{"location":"#Managing-recyclers","page":"Recyclers.jl","title":"Managing recyclers","text":"","category":"section"},{"location":"","page":"Recyclers.jl","title":"Recyclers.jl","text":"Recyclers.unsafe_empty!\nRecyclers.unsafe_init!\nRecyclers.unsafe_destroy!","category":"page"},{"location":"#Recyclers.unsafe_empty!","page":"Recyclers.jl","title":"Recyclers.unsafe_empty!","text":"Recyclers.unsafe_empty!(recycler::AbstractRecycler) -> recycler\nRecyclers.unsafe_empty!(cache::AbstractCache) -> cache\n\nEmpty a cache or underlying cache of a recycler to help garbage collecting pooled objects.  It is unsafe in the sense that there is no protection against accesses from other tasks; i.e., the programmer calling this function is responsible for ensuring that no concurrent tasks are accessing recycler.\n\n\n\n\n\n","category":"function"},{"location":"#Recyclers.unsafe_init!","page":"Recyclers.jl","title":"Recyclers.unsafe_init!","text":"Recyclers.unsafe_init!(recycler) -> recycler\n\nRe-initialize recycler.  It is unsafe in the sense that there is no protection against accesses from other tasks; i.e., the programmer calling this function is responsible for ensuring that no concurrent tasks are accessing recycler.\n\n\n\n\n\n","category":"function"},{"location":"#Recyclers.unsafe_destroy!","page":"Recyclers.jl","title":"Recyclers.unsafe_destroy!","text":"Recyclers.unsafe_destroy!(recycler::AbstractRecycler) -> recycler\nRecyclers.unsafe_destroy!(cache::AbstractCache) -> cache\n\nDestroy a cache or underlying cache of a recycler, typically to minimize serialized global cache.  The cache and recycler cannot be used unless Recyclers.unsafe_init! is called first.  It is unsafe in the sense that there is no protection against accesses from other tasks; i.e., the programmer calling this function is responsible for ensuring that no concurrent tasks are accessing recycler.\n\n\n\n\n\n","category":"function"}]
}
